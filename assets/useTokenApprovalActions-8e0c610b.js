import{u as j,b as I,af as C,ag as E,o as B,c as q,y as N,cK as h,aa as z,cJ as J,fc as K,z as P,q as O}from"./index-4a1c513c.js";var c=(n=>(n[n.AddLiquidity=0]="AddLiquidity",n[n.Locking=1]="Locking",n[n.Staking=2]="Staking",n))(c||{});function R(n,l,v=c.AddLiquidity){const{getSigner:r,appNetworkConfig:g,account:w}=j(),{getToken:f,refetchAllowances:S,approvalsRequired:y,getTokens:A}=I(),{txListener:F}=C(),{addTransaction:M}=E(),{t:m}=B(),L=q(()=>Object.fromEntries(y(n.value,l.value,g.addresses.vault).map(a=>[a,{init:!1,confirming:!1,approved:!1}]))),x=N(!1),p=q(()=>y(n.value,l.value,g.addresses.vault));function t(a){var s,i,o;switch(v){case c.Locking:return m("transactionSummary.approveForLocking",[(s=f(a))==null?void 0:s.symbol]);case c.Staking:return m("transactionSummary.approveForStaking",[(i=f(a))==null?void 0:i.symbol]);default:return m("transactionSummary.approveForInvesting",[(o=f(a))==null?void 0:o.symbol])}}async function u(a,s={}){const i={spender:g.addresses.vault,amount:h.toString(),state:L.value[a]},{spender:o,amount:T,state:e}=Object.assign(i,s);try{e.init=!0;const b=await new z(r()).contract.sendTransaction({contractAddress:a,abi:J,action:"approve",params:[o,T]});return e.init=!1,e.confirming=!0,M({id:b.hash,type:"tx",action:"approve",summary:t(a),details:{contractAddress:a,spender:o}}),F(b,{onTxConfirmed:async()=>{await S(),e.confirming=!1,e.approved=!0},onTxFailed:()=>{e.confirming=!1}}),b}catch(k){return e.confirming=!1,e.init=!1,console.error(k),Promise.reject(k)}}async function d(a){const s=A(n.value),i=await K.allowances.get(w.value,[a],s),o=n.value.filter((e,k)=>P(i[O(a)][O(e)]).lt(l.value[k])).map(e=>[e,{init:!1,confirming:!1,approved:!1}]);return Object.fromEntries(o)}return{vaultApprovalStateMap:L,approving:x,requiredApprovals:p,approveToken:u,getApprovalStateMapFor:d}}function W(n,l,v=c.AddLiquidity){const{t:r}=B(),{getToken:g}=I(),{vaultApprovalStateMap:w,approveToken:f,getApprovalStateMapFor:S}=R(n,l,v),{appNetworkConfig:y}=j(),A=y.addresses.vault,F=p();function M(t){switch(v){case c.Locking:return r("transactionSummary.approveForLocking",[t]);case c.Staking:return r("transactionSummary.approveForStaking",[t]);default:return r("transactionSummary.approveForInvesting",[t])}}function m(t){switch(v){case c.Locking:return r("transactionSummary.tooltips.approveForLocking",[t]);case c.Staking:return r("transactionSummary.tooltips.approveForStaking",[t]);default:return r("transactionSummary.tooltips.approveForInvesting",[t])}}async function L(t,u=h.toString()){const d=await S(t);return p({spender:t,amount:u,stateMap:d})}async function x(t){const u=await S(t);return p({stateMap:u})}function p(t={}){const u={spender:A,amount:h.toString(),stateMap:w.value},{spender:d,amount:a,stateMap:s}=Object.assign(u,t);return Object.keys(s).map(i=>{const o=g(i),T=s[i];return{label:M(o.symbol),loadingLabel:r("investment.preview.loadingLabel.approval"),confirmingLabel:r("confirming"),stepTooltip:m(o.symbol),action:()=>f(o.address,{spender:d,state:T,amount:a})}})}return{tokenApprovalActions:F,getTokenApprovalActions:p,getTokenApprovalActionsForSpender:L,fetchTokenApprovalActions:x}}export{c as A,W as u};
//# sourceMappingURL=useTokenApprovalActions-8e0c610b.js.map
