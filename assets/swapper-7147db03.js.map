{"version":3,"file":"swapper-7147db03.js","sources":["../../src/services/cowswap/utils.ts","../../src/services/contracts/vault.service.ts","../../src/services/contracts/lido-relayer.service.ts","../../src/services/swap/swap.service.ts","../../src/lib/utils/balancer/swapper.ts"],"sourcesContent":["import { configService } from '../config/config.service';\r\nimport { MAX_VALID_TO_EPOCH } from './constants';\r\n\r\nexport function toErc20Address(tokenAddress: string) {\r\n  const nativeAssetAddress = configService.network.nativeAsset.address;\r\n\r\n  if (tokenAddress.toLowerCase() === nativeAssetAddress.toLowerCase()) {\r\n    return configService.network.addresses.weth;\r\n  }\r\n\r\n  return tokenAddress;\r\n}\r\n\r\nexport function calculateValidTo(deadlineInMinutes: number): number {\r\n  const now = Date.now() / 1000;\r\n  const validTo = Math.floor(deadlineInMinutes * 60 + now);\r\n\r\n  return Math.min(validTo, MAX_VALID_TO_EPOCH);\r\n}\r\n","import {\r\n  FundManagement,\r\n  SingleSwap,\r\n  SwapType,\r\n  SwapV2,\r\n} from '@balancer-labs/sdk';\r\nimport { Vault__factory } from '@balancer-labs/typechain';\r\nimport { TransactionResponse } from '@ethersproject/abstract-provider';\r\nimport { ContractInterface } from '@ethersproject/contracts';\r\n\r\nimport { calculateValidTo } from '../cowswap/utils';\r\n\r\nimport ConfigService, { configService } from '@/services/config/config.service';\r\n\r\nimport WalletService, {\r\n  walletService as walletServiceInstance,\r\n} from '@/services/web3/wallet.service';\r\n\r\nexport default class VaultService {\r\n  abi: ContractInterface;\r\n\r\n  constructor(\r\n    protected readonly config: ConfigService = configService,\r\n    private readonly walletService: WalletService = walletServiceInstance\r\n  ) {\r\n    this.abi = Vault__factory.abi;\r\n  }\r\n\r\n  get address() {\r\n    return this.config.network.addresses.vault;\r\n  }\r\n\r\n  public swap(\r\n    single: SingleSwap,\r\n    funds: FundManagement,\r\n    tokenOutAmount: string,\r\n    transactionDeadline: number,\r\n    options: Record<string, any> = {}\r\n  ): Promise<TransactionResponse> {\r\n    const deadline = calculateValidTo(transactionDeadline);\r\n    return this.walletService.txBuilder.contract.sendTransaction({\r\n      contractAddress: this.address,\r\n      abi: this.abi,\r\n      action: 'swap',\r\n      params: [single, funds, tokenOutAmount, deadline],\r\n      options,\r\n    });\r\n  }\r\n\r\n  public batchSwap(\r\n    swapKind: SwapType,\r\n    swaps: SwapV2[],\r\n    tokenAddresses: string[],\r\n    funds: FundManagement,\r\n    limits: string[],\r\n    transactionDeadline: number,\r\n    options: Record<string, any> = {}\r\n  ): Promise<TransactionResponse> {\r\n    const deadline = calculateValidTo(transactionDeadline);\r\n    return this.walletService.txBuilder.contract.sendTransaction({\r\n      contractAddress: this.address,\r\n      abi: this.abi,\r\n      action: 'batchSwap',\r\n      params: [swapKind, swaps, tokenAddresses, funds, limits, deadline],\r\n      options,\r\n    });\r\n  }\r\n}\r\n\r\nexport const vaultService = new VaultService();\r\n","import { LidoRelayer__factory } from '@balancer-labs/typechain';\r\n\r\nimport VaultService from '@/services/contracts/vault.service';\r\n\r\nexport default class LidoRelayerService extends VaultService {\r\n  constructor() {\r\n    super();\r\n    this.abi = LidoRelayer__factory.abi;\r\n  }\r\n\r\n  get address() {\r\n    return this.config.network.addresses.lidoRelayer;\r\n  }\r\n}\r\n\r\nexport const lidoRelayerService = new LidoRelayerService();\r\n","import {\r\n  BatchSwapStep,\r\n  FundManagement,\r\n  SingleSwap,\r\n  SwapType,\r\n  SwapV2,\r\n} from '@balancer-labs/sdk';\r\nimport { TransactionResponse } from '@ethersproject/abstract-provider';\r\nimport { BigNumber } from '@ethersproject/bignumber';\r\nimport { AddressZero } from '@ethersproject/constants';\r\n\r\nimport { isSameAddress } from '@/lib/utils';\r\nimport { getWstETHByStETH, isStETH } from '@/lib/utils/balancer/lido';\r\nimport ConfigService, { configService } from '@/services/config/config.service';\r\nimport { lidoRelayerService } from '@/services/contracts/lido-relayer.service';\r\nimport { vaultService } from '@/services/contracts/vault.service';\r\n\r\nimport { walletService as walletServiceInstance } from '@/services/web3/wallet.service';\r\n\r\nexport type Address = string;\r\n\r\nexport enum SwapTokenType {\r\n  fixed,\r\n  min,\r\n  max,\r\n}\r\n\r\nexport interface SwapToken {\r\n  address: Address;\r\n  amount: BigNumber;\r\n  type: SwapTokenType;\r\n}\r\n\r\nexport default class SwapService {\r\n  constructor(\r\n    private readonly config: ConfigService = configService,\r\n    private readonly walletService = walletServiceInstance\r\n  ) {}\r\n\r\n  public async batchSwapV2(\r\n    tokenIn: SwapToken,\r\n    tokenOut: SwapToken,\r\n    swaps: SwapV2[],\r\n    tokenAddresses: string[]\r\n  ): Promise<TransactionResponse> {\r\n    if (isStETH(tokenIn.address, tokenOut.address)) {\r\n      return this.lidoBatchSwap(tokenIn, tokenOut, swaps, tokenAddresses);\r\n    }\r\n    console.log('[Swap Service] batchSwapV2');\r\n    const overrides: any = {};\r\n\r\n    if (isSameAddress(tokenIn.address, AddressZero)) {\r\n      overrides.value = tokenIn.amount;\r\n    }\r\n\r\n    const swapKind =\r\n      tokenOut.type === SwapTokenType.min\r\n        ? SwapType.SwapExactIn\r\n        : SwapType.SwapExactOut;\r\n\r\n    const funds = await this.getFundManagement();\r\n\r\n    try {\r\n      if (swaps.length == 1) {\r\n        const single: SingleSwap = {\r\n          poolId: swaps[0].poolId,\r\n          kind: swapKind,\r\n          assetIn: tokenAddresses[swaps[0].assetInIndex],\r\n          assetOut: tokenAddresses[swaps[0].assetOutIndex],\r\n          amount: swaps[0].amount,\r\n          userData: swaps[0].userData,\r\n        };\r\n\r\n        /*\r\n        See docs in iVault:\r\n        If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\r\n        taken from the Pool, which must be greater than or equal to `limit`.\r\n        If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\r\n        sent to the Pool, which must be less than or equal to `limit`.\r\n        */\r\n        const limit =\r\n          swapKind === SwapType.SwapExactIn\r\n            ? tokenOut.amount.toString()\r\n            : tokenIn.amount.toString();\r\n\r\n        return vaultService.swap(single, funds, limit, overrides);\r\n      }\r\n\r\n      const limits: string[] = this.calculateLimits(\r\n        [tokenIn],\r\n        [tokenOut],\r\n        tokenAddresses\r\n      );\r\n\r\n      return vaultService.batchSwap(\r\n        swapKind,\r\n        swaps,\r\n        tokenAddresses,\r\n        funds,\r\n        limits,\r\n        overrides\r\n      );\r\n    } catch (e) {\r\n      console.log('[Swapper] batchSwapV2 Error:', e);\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n  public async lidoBatchSwap(\r\n    tokenIn: SwapToken,\r\n    tokenOut: SwapToken,\r\n    swaps: SwapV2[],\r\n    tokenAddresses: string[]\r\n  ): Promise<TransactionResponse> {\r\n    console.log('[Swapper] lidoBatchSwap');\r\n    const overrides: any = {};\r\n\r\n    if (isSameAddress(tokenIn.address, AddressZero)) {\r\n      overrides.value = tokenIn.amount;\r\n    }\r\n\r\n    // Convert tokenIn/tokenOut so that it matches what's in tokenAddresses\r\n    const { stETH, wstETH } = this.config.network.addresses;\r\n    if (tokenIn.address.toLowerCase() === stETH.toLowerCase()) {\r\n      tokenIn = {\r\n        address: wstETH.toLowerCase(),\r\n        amount: await getWstETHByStETH(tokenIn.amount),\r\n        type: tokenIn.type,\r\n      };\r\n    } else if (tokenOut.address.toLowerCase() === stETH.toLowerCase()) {\r\n      tokenOut = {\r\n        address: wstETH.toLowerCase(),\r\n        amount: await getWstETHByStETH(tokenOut.amount),\r\n        type: tokenOut.type,\r\n      };\r\n    }\r\n\r\n    const swapKind =\r\n      tokenOut.type === SwapTokenType.min\r\n        ? SwapType.SwapExactIn\r\n        : SwapType.SwapExactOut;\r\n\r\n    const funds = await this.getFundManagement();\r\n\r\n    try {\r\n      if (swaps.length == 1) {\r\n        const single: SingleSwap = {\r\n          poolId: swaps[0].poolId,\r\n          kind: swapKind,\r\n          assetIn: tokenAddresses[swaps[0].assetInIndex],\r\n          assetOut: tokenAddresses[swaps[0].assetOutIndex],\r\n          amount: swaps[0].amount,\r\n          userData: swaps[0].userData,\r\n        };\r\n\r\n        return lidoRelayerService.swap(\r\n          single,\r\n          funds,\r\n          tokenOut.amount.toString(),\r\n          overrides\r\n        );\r\n      }\r\n\r\n      const limits = this.calculateLimits(\r\n        [tokenIn],\r\n        [tokenOut],\r\n        tokenAddresses\r\n      );\r\n\r\n      return lidoRelayerService.batchSwap(\r\n        swapKind,\r\n        swaps,\r\n        tokenAddresses,\r\n        funds,\r\n        limits,\r\n        overrides\r\n      );\r\n    } catch (e) {\r\n      console.log('[Swapper] lidoBatchSwap Error:', e);\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Join a Boosted Pool (StablePhantom) using a batch swap\r\n   */\r\n  public async boostedJoinBatchSwap(\r\n    tokensIn: SwapToken[],\r\n    tokenOut: SwapToken,\r\n    swaps: SwapV2[],\r\n    tokenAddresses: string[]\r\n  ) {\r\n    try {\r\n      const overrides: any = {};\r\n      const funds = await this.getFundManagement();\r\n\r\n      const limits: string[] = this.calculateLimits(\r\n        tokensIn,\r\n        [tokenOut],\r\n        tokenAddresses\r\n      );\r\n\r\n      return vaultService.batchSwap(\r\n        SwapType.SwapExactIn,\r\n        swaps,\r\n        tokenAddresses,\r\n        funds,\r\n        limits,\r\n        overrides\r\n      );\r\n    } catch (error) {\r\n      console.log('[Swapper] batchSwapGivenInV2 Error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Exit a Boosted Pool (StablePhantom) using a batch swap\r\n   */\r\n  public async boostedExitBatchSwap(\r\n    tokenIn: SwapToken,\r\n    tokensOut: SwapToken[],\r\n    swaps: BatchSwapStep[],\r\n    tokenAddresses: string[],\r\n    swapKind: SwapType\r\n  ): Promise<TransactionResponse> {\r\n    try {\r\n      const overrides: any = {};\r\n      const funds = await this.getFundManagement();\r\n\r\n      const limits: string[] = this.calculateLimits(\r\n        [tokenIn],\r\n        tokensOut,\r\n        tokenAddresses\r\n      );\r\n\r\n      console.log('limits', limits);\r\n\r\n      return vaultService.batchSwap(\r\n        swapKind,\r\n        swaps,\r\n        tokenAddresses,\r\n        funds,\r\n        limits,\r\n        overrides\r\n      );\r\n    } catch (error) {\r\n      console.log('[Swapper] batchSwapGivenInV2 Error:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private async getFundManagement(): Promise<FundManagement> {\r\n    const userAddress = await this.walletService.getUserAddress();\r\n    const funds: FundManagement = {\r\n      sender: userAddress,\r\n      recipient: userAddress,\r\n      fromInternalBalance: false,\r\n      toInternalBalance: false,\r\n    };\r\n    return funds;\r\n  }\r\n\r\n  public calculateLimits(\r\n    tokensIn: SwapToken[],\r\n    tokensOut: SwapToken[],\r\n    tokenAddresses: string[]\r\n  ): string[] {\r\n    const limits: string[] = [];\r\n\r\n    tokenAddresses.forEach((token, i) => {\r\n      const tokenIn = tokensIn.find(\r\n        swapToken => token.toLowerCase() === swapToken.address.toLowerCase()\r\n      );\r\n      const tokenOut = tokensOut.find(\r\n        swapToken => token.toLowerCase() === swapToken.address.toLowerCase()\r\n      );\r\n      if (tokenIn) {\r\n        limits[i] = tokenIn.amount.toString();\r\n      } else if (tokenOut) {\r\n        limits[i] = tokenOut.amount.mul(-1).toString();\r\n      } else {\r\n        limits[i] = '0';\r\n      }\r\n    });\r\n\r\n    console.log('Limits', limits);\r\n    return limits;\r\n  }\r\n}\r\n\r\nexport const swapService = new SwapService();\r\n","import { BatchSwapStep, SwapType, SwapV2 } from '@balancer-labs/sdk';\r\nimport { BigNumber } from '@ethersproject/bignumber';\r\nimport { TransactionResponse } from '@ethersproject/providers';\r\n\r\nimport { SorReturn } from '@/lib/utils/balancer/helpers/sor/sorManager';\r\nimport {\r\n  swapService,\r\n  SwapToken,\r\n  SwapTokenType,\r\n} from '@/services/swap/swap.service';\r\n\r\nexport async function swapIn(\r\n  sorReturn: SorReturn,\r\n  tokenInAmount: BigNumber,\r\n  tokenOutAmountMin: BigNumber\r\n): Promise<TransactionResponse> {\r\n  const tokenInAddress = sorReturn.result.tokenIn;\r\n  const tokenOutAddress = sorReturn.result.tokenOut;\r\n\r\n  const tokenIn: SwapToken = {\r\n    address: tokenInAddress,\r\n    amount: tokenInAmount,\r\n    type: SwapTokenType.fixed,\r\n  };\r\n\r\n  const tokenOut: SwapToken = {\r\n    address: tokenOutAddress,\r\n    amount: tokenOutAmountMin,\r\n    type: SwapTokenType.min,\r\n  };\r\n\r\n  return swapService.batchSwapV2(\r\n    tokenIn,\r\n    tokenOut,\r\n    sorReturn.result.swaps,\r\n    sorReturn.result.tokenAddresses\r\n  );\r\n}\r\n\r\nexport async function swapOut(\r\n  sorReturn: SorReturn,\r\n  tokenInAmountMax: BigNumber,\r\n  tokenOutAmount: BigNumber\r\n): Promise<TransactionResponse> {\r\n  const tokenInAddress = sorReturn.result.tokenIn;\r\n  const tokenOutAddress = sorReturn.result.tokenOut;\r\n\r\n  const tokenIn: SwapToken = {\r\n    address: tokenInAddress,\r\n    amount: tokenInAmountMax,\r\n    type: SwapTokenType.max,\r\n  };\r\n\r\n  const tokenOut: SwapToken = {\r\n    address: tokenOutAddress,\r\n    amount: tokenOutAmount,\r\n    type: SwapTokenType.fixed,\r\n  };\r\n\r\n  return swapService.batchSwapV2(\r\n    tokenIn,\r\n    tokenOut,\r\n    sorReturn.result.swaps,\r\n    sorReturn.result.tokenAddresses\r\n  );\r\n}\r\n\r\nexport async function boostedJoinBatchSwap(\r\n  swaps: SwapV2[],\r\n  tokenAddresses: string[],\r\n  tokenOutAddress: string,\r\n  amountsInMap: Record<string, BigNumber>,\r\n  amountOutMin: BigNumber\r\n) {\r\n  const tokensIn: SwapToken[] = Object.entries(amountsInMap).map(\r\n    ([address, amount]) => {\r\n      return {\r\n        address,\r\n        amount,\r\n        type: SwapTokenType.fixed,\r\n      };\r\n    }\r\n  );\r\n  const tokenOut: SwapToken = {\r\n    address: tokenOutAddress,\r\n    amount: amountOutMin,\r\n    type: SwapTokenType.min,\r\n  };\r\n  return swapService.boostedJoinBatchSwap(\r\n    tokensIn,\r\n    tokenOut,\r\n    swaps,\r\n    tokenAddresses\r\n  );\r\n}\r\n\r\nexport async function boostedExitBatchSwap(\r\n  swaps: BatchSwapStep[],\r\n  tokenAddresses: string[],\r\n  tokenInAddress: string,\r\n  amountIn: string,\r\n  amountsOutMap: Record<string, string>,\r\n  swapKind: SwapType = SwapType.SwapExactIn\r\n): Promise<TransactionResponse> {\r\n  const tokenIn: SwapToken = {\r\n    address: tokenInAddress,\r\n    amount: BigNumber.from(amountIn),\r\n    type: SwapTokenType.min,\r\n  };\r\n\r\n  const tokensOut: SwapToken[] = Object.entries(amountsOutMap).map(\r\n    ([address, amount]) => {\r\n      return {\r\n        address,\r\n        amount: BigNumber.from(amount),\r\n        type: SwapTokenType.fixed,\r\n      };\r\n    }\r\n  );\r\n  return swapService.boostedExitBatchSwap(\r\n    tokenIn,\r\n    tokensOut,\r\n    swaps,\r\n    tokenAddresses,\r\n    swapKind\r\n  );\r\n}\r\n"],"names":["calculateValidTo","deadlineInMinutes","now","validTo","MAX_VALID_TO_EPOCH","VaultService","config","configService","walletService","walletServiceInstance","__publicField","Vault__factory","single","funds","tokenOutAmount","transactionDeadline","options","deadline","swapKind","swaps","tokenAddresses","limits","vaultService","LidoRelayerService","LidoRelayer__factory","lidoRelayerService","SwapTokenType","SwapTokenType2","SwapService","tokenIn","tokenOut","isStETH","overrides","isSameAddress","AddressZero","SwapType","limit","e","stETH","wstETH","getWstETHByStETH","tokensIn","error","tokensOut","userAddress","token","i","swapToken","swapService","swapIn","sorReturn","tokenInAmount","tokenOutAmountMin","tokenInAddress","tokenOutAddress","swapOut","tokenInAmountMax","boostedJoinBatchSwap","amountsInMap","amountOutMin","address","amount","boostedExitBatchSwap","amountIn","amountsOutMap","BigNumber"],"mappings":"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"}