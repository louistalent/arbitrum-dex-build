{"version":3,"file":"useWithdrawMath-4e11940a.js","sources":["../../src/components/forms/pool_actions/WithdrawForm/composables/useWithdrawalState.ts","../../src/components/forms/pool_actions/WithdrawForm/composables/useWithdrawMath.ts"],"sourcesContent":["import { computed, reactive, Ref, toRefs } from 'vue';\r\n\r\nimport { isDeep, tokensListExclBpt } from '@/composables/usePool';\r\nimport useRelayerApprovalTx from '@/composables/approvals/useRelayerApprovalTx';\r\nimport { useTokens } from '@/providers/tokens.provider';\r\nimport i18n from '@/plugins/i18n';\r\nimport { Pool } from '@/services/pool/types';\r\nimport { BaseContent } from '@/types';\r\nimport { TransactionReceipt } from '@ethersproject/abstract-provider';\r\nimport { useTokenHelpers } from '@/composables/useTokenHelpers';\r\nimport { RelayerType } from '@/composables/approvals/useRelayerApproval';\r\n\r\n/**\r\n * TYPES\r\n */\r\nexport enum WithdrawalError {\r\n  SINGLE_ASSET_WITHDRAWAL_MIN_BPT_LIMIT = 'SINGLE_ASSET_WITHDRAWAL_MIN_BPT_LIMIT',\r\n}\r\n\r\ntype WithdrawalState = {\r\n  isProportional: boolean;\r\n  tokenOut: string;\r\n  validInput: boolean;\r\n  highPriceImpactAccepted: boolean;\r\n  submitting: boolean;\r\n  sorReady: boolean;\r\n  tx: {\r\n    init: boolean;\r\n    confirming: boolean;\r\n    confirmed: boolean;\r\n    confirmedAt: string;\r\n    receipt?: TransactionReceipt;\r\n  };\r\n  slider: {\r\n    val: number;\r\n    max: number;\r\n    min: number;\r\n    interval: number;\r\n  };\r\n  error: WithdrawalError | null;\r\n};\r\n\r\n/**\r\n * STATE\r\n */\r\nconst state = reactive<WithdrawalState>({\r\n  isProportional: true,\r\n  tokenOut: '',\r\n  validInput: true,\r\n  highPriceImpactAccepted: false,\r\n  submitting: false,\r\n  sorReady: false,\r\n  tx: {\r\n    init: false,\r\n    confirming: false,\r\n    confirmed: false,\r\n    confirmedAt: '',\r\n  },\r\n  slider: {\r\n    val: 1000,\r\n    max: 1000,\r\n    min: 0,\r\n    interval: 1,\r\n  },\r\n  error: null,\r\n});\r\n\r\n/**\r\n * METHODS\r\n */\r\nexport function setError(error: WithdrawalError | null): void {\r\n  state.error = error;\r\n}\r\n\r\nexport function resetTxState(): void {\r\n  state.tx = {\r\n    init: false,\r\n    confirming: false,\r\n    confirmed: false,\r\n    confirmedAt: '',\r\n  };\r\n}\r\n\r\nexport function parseError(error: WithdrawalError): BaseContent {\r\n  switch (error) {\r\n    case WithdrawalError.SINGLE_ASSET_WITHDRAWAL_MIN_BPT_LIMIT:\r\n      return {\r\n        title: i18n.global.t('warning'),\r\n        description: i18n.global.t(\r\n          `withdraw.errors.${WithdrawalError.SINGLE_ASSET_WITHDRAWAL_MIN_BPT_LIMIT}`\r\n        ),\r\n      };\r\n    default:\r\n      return {\r\n        title: i18n.global.t('Ooops'),\r\n        description: i18n.global.t('somethingWentWrong'),\r\n      };\r\n  }\r\n}\r\n\r\nconst txInProgress = computed(\r\n  (): boolean => state.tx.init || state.tx.confirming || state.tx.confirmed\r\n);\r\n\r\nexport default function useWithdrawalState(pool: Ref<Pool | undefined>) {\r\n  /**\r\n   * COMPOSABLES\r\n   */\r\n  const { nativeAsset } = useTokens();\r\n  const { replaceWethWithEth } = useTokenHelpers();\r\n  const batchRelayerApproval = useRelayerApprovalTx(RelayerType.BATCH);\r\n\r\n  /**\r\n   * COMPUTED\r\n   */\r\n  const tokensOut = computed(() => {\r\n    if (!pool.value) return [];\r\n\r\n    const poolTokens = isDeep(pool.value)\r\n      ? pool.value.mainTokens || []\r\n      : tokensListExclBpt(pool.value);\r\n\r\n    if (!state.isProportional && state.tokenOut === nativeAsset.address)\r\n      // replace WETH with ETH\r\n      return replaceWethWithEth(poolTokens);\r\n\r\n    return poolTokens;\r\n  });\r\n\r\n  const tokenOutIndex = computed(() => {\r\n    return tokensOut.value.indexOf(state.tokenOut);\r\n  });\r\n\r\n  /**\r\n   * METHODS\r\n   */\r\n  function maxSlider(): void {\r\n    state.slider.val = state.slider.max;\r\n  }\r\n\r\n  return {\r\n    ...toRefs(state),\r\n    tokensOut,\r\n    tokenOutIndex,\r\n    batchRelayerApproval,\r\n    txInProgress,\r\n    // methods\r\n    maxSlider,\r\n    setError,\r\n    parseError,\r\n    resetTxState,\r\n  };\r\n}\r\n","/**\r\n * useWithdrawMath\r\n *\r\n * Returns state, computed properties and methods for the withdraw form math.\r\n *\r\n * TODO:\r\n * Requires major refactor following Boosted pools (StablePhantom) logic additions.\r\n */\r\nimport {\r\n  BalancerError,\r\n  BalancerErrorCode,\r\n  SwapType,\r\n  TransactionData,\r\n} from '@balancer-labs/sdk';\r\nimport { formatUnits, parseUnits } from '@ethersproject/units';\r\nimport OldBigNumber from 'bignumber.js';\r\nimport { computed, Ref, ref, watch } from 'vue';\r\n\r\nimport useNumbers, { FNumFormats } from '@/composables/useNumbers';\r\nimport { isDeep, tokensListExclBpt, usePool } from '@/composables/usePool';\r\nimport usePromiseSequence from '@/composables/usePromiseSequence';\r\nimport useSlippage from '@/composables/useSlippage';\r\nimport { useTokens } from '@/providers/tokens.provider';\r\n// Composables\r\nimport { useUserSettings } from '@/providers/user-settings.provider';\r\nimport { HIGH_PRICE_IMPACT } from '@/constants/poolLiquidity';\r\nimport { getBalancer } from '@/dependencies/balancer-sdk';\r\nimport {\r\n  bnSum,\r\n  bnum,\r\n  forChange,\r\n  indexOfAddress,\r\n  isSameAddress,\r\n} from '@/lib/utils';\r\nimport { balancerContractsService } from '@/services/balancer/contracts/balancer-contracts.service';\r\n// Services\r\nimport PoolCalculator from '@/services/pool/calculator/calculator.sevice';\r\n// Types\r\nimport { Pool } from '@/services/pool/types';\r\nimport useWeb3 from '@/services/web3/useWeb3';\r\nimport { BatchSwapOut } from '@/types';\r\nimport { TokenInfo } from '@/types/TokenList';\r\n\r\nimport { setError, WithdrawalError } from './useWithdrawalState';\r\nimport { cloneDeep, isEqual } from 'lodash';\r\nimport { SHALLOW_COMPOSABLE_STABLE_BUFFER } from '@/constants/pools';\r\n\r\nimport PoolExchange from '@/services/pool/exchange/exchange.service';\r\nimport { useTokenHelpers } from '@/composables/useTokenHelpers';\r\nimport { PoolDecorator } from '@/services/pool/decorators/pool.decorator';\r\n\r\n/**\r\n * TYPES\r\n */\r\nexport type WithdrawMathResponse = ReturnType<typeof useWithdrawMath>;\r\n\r\nexport default function useWithdrawMath(\r\n  pool: Ref<Pool>,\r\n  isProportional: Ref<boolean> = ref(true),\r\n  tokensOut: Ref<string[]> = ref([]),\r\n  tokenOut: Ref<string> = ref(''),\r\n  tokenOutIndex: Ref<number> = ref(0)\r\n) {\r\n  /**\r\n   * STATE\r\n   */\r\n  const propBptIn = ref<string>('0');\r\n  const tokenOutAmount = ref<string>('');\r\n\r\n  const loadingData = ref(false);\r\n  const queryBptIn = ref<string>('');\r\n  const evmGuideBptIn = ref<string>('0');\r\n  const batchSwap = ref<BatchSwapOut | null>(null);\r\n  const batchRelayerSwap = ref<any | null>(null);\r\n\r\n  // This array can be set by either a queryExit, a regular batch swap result\r\n  // or a batch relayer result, if the batch swap returns 0.\r\n  const fetchedSingleAssetMaxes = ref<string[]>([]);\r\n\r\n  /**\r\n   * COMPOSABLES\r\n   */\r\n  const { isWalletReady, getSigner, account } = useWeb3();\r\n  const { toFiat, fNum } = useNumbers();\r\n  const {\r\n    tokens: allTokens,\r\n    balances,\r\n    balanceFor,\r\n    getToken,\r\n    dynamicDataLoading,\r\n    nativeAsset,\r\n  } = useTokens();\r\n  const { replaceWethWithEth } = useTokenHelpers();\r\n  const { minusSlippage, addSlippageScaled, minusSlippageScaled } =\r\n    useSlippage();\r\n  const { isWeightedPool, isDeepPool, isShallowComposableStablePool } =\r\n    usePool(pool);\r\n  const { slippageScaled } = useUserSettings();\r\n  const {\r\n    promises: swapPromises,\r\n    processing: processingSwaps,\r\n    processAll: processSwaps,\r\n  } = usePromiseSequence();\r\n\r\n  /**\r\n   * SERVICES\r\n   */\r\n  const poolCalculator = new PoolCalculator(pool, allTokens, balances, 'exit');\r\n  const poolExchange = new PoolExchange(pool);\r\n\r\n  /**\r\n   * COMPUTED\r\n   */\r\n  const tokenAddresses = computed((): string[] => {\r\n    if (isDeep(pool.value)) {\r\n      return pool.value.mainTokens || [];\r\n    }\r\n    return tokensListExclBpt(pool.value);\r\n  });\r\n\r\n  const tokenCount = computed((): number => tokenAddresses.value.length);\r\n\r\n  // The tokens of the pool\r\n  const poolTokens = computed((): TokenInfo[] =>\r\n    tokensListExclBpt(pool.value).map(address => getToken(address))\r\n  );\r\n\r\n  const tokenOutDecimals = computed(\r\n    (): number => getToken(tokenOut.value).decimals\r\n  );\r\n\r\n  const poolDecimals = computed(\r\n    (): number => pool.value?.onchain?.decimals || 18\r\n  );\r\n\r\n  /**\r\n   * The tokens being withdrawn\r\n   * In most cases these are the same as the pool tokens\r\n   * except for Stable Phantom pools\r\n   */\r\n  const withdrawalTokens = computed((): TokenInfo[] =>\r\n    tokenAddresses.value.map(address => getToken(address))\r\n  );\r\n\r\n  const bptBalance = computed((): string => balanceFor(pool.value.address));\r\n\r\n  const bptBalanceScaled = computed((): string =>\r\n    parseUnits(bptBalance.value, poolDecimals.value).toString()\r\n  );\r\n\r\n  /**\r\n   * Returns the absolute max BPT withdrawable from a pool.\r\n   * In most cases this is just the user's BPT balance.\r\n   *\r\n   * However, for weighted pools, if the user is a majority LP they may\r\n   * only be able to withdraw up to the 30% limit.\r\n   */\r\n  const absMaxBpt = computed((): string => {\r\n    if (!isWeightedPool.value) return bptBalance.value;\r\n    // Maximum BPT allowed from weighted pool is 30%\r\n    const poolMax = bnum(pool.value.totalShares)\r\n      .times(0.3)\r\n      .toFixed(poolDecimals.value, OldBigNumber.ROUND_DOWN);\r\n    // If the user's bpt balance is greater than the withdrawal limit for\r\n    // weighted pools we need to return the poolMax bpt value.\r\n    return OldBigNumber.min(bptBalance.value, poolMax).toString();\r\n  });\r\n\r\n  const hasBpt = computed(() => bnum(bptBalance.value).gt(0));\r\n\r\n  const tokenOutPoolBalance = computed(() => {\r\n    const tokens = pool.value?.onchain?.tokens || [];\r\n    const balances = Object.values(tokens).map(token => token.balance);\r\n    return balances[tokenOutIndex.value];\r\n  });\r\n\r\n  const amountExceedsPoolBalance = computed(() =>\r\n    bnum(tokenOutAmount.value).gt(tokenOutPoolBalance.value)\r\n  );\r\n\r\n  // To account for exact maths required in BPTInForExactTokensOut cases.\r\n  const shouldUseBptBuffer = computed(\r\n    (): boolean => isProportional.value && isShallowComposableStablePool.value\r\n  );\r\n\r\n  const bptBuffer = computed((): number =>\r\n    shouldUseBptBuffer.value ? SHALLOW_COMPOSABLE_STABLE_BUFFER : 0\r\n  );\r\n\r\n  /**\r\n   * Proportional pool token amounts out given BPT in.\r\n   * Only relevant for exit calls, not batchSwap or batch relayer exits.\r\n   */\r\n  const proportionalPoolTokenAmounts = computed((): string[] => {\r\n    let fixedRatioOverride;\r\n    if (shouldUseBptBuffer.value && bnum(evmGuideBptIn.value).gt(0)) {\r\n      fixedRatioOverride = {\r\n        bps: 1000, // 10%\r\n        value: evmGuideBptIn.value,\r\n        buffer: bptBuffer.value,\r\n      };\r\n    }\r\n\r\n    const { receive } = poolCalculator.propAmountsGiven(\r\n      propBptIn.value,\r\n      0,\r\n      'send',\r\n      fixedRatioOverride\r\n    );\r\n\r\n    return receive;\r\n  });\r\n\r\n  /**\r\n   * Proportional amounts out for a StablePhantom pool's output tokens.\r\n   * Derived from queryBatchSwap or batchRelayer amounts out result.\r\n   * Output tokens could be the mainTokens or unwrapped wrapped tokens.\r\n   * e.g. USDC, USDT, DAI or aUSDC, aUSDT, aDAI\r\n   */\r\n  const proportionalMainTokenAmounts = computed((): string[] => {\r\n    if (shouldUseBatchRelayer.value && batchRelayerSwap.value) {\r\n      return batchRelayerSwap.value.outputs.amountsOut.map((amount, i) => {\r\n        const _amount = bnum(amount.toString()).abs().toString();\r\n        return formatUnits(_amount, withdrawalTokens.value[i].decimals);\r\n      });\r\n    } else if (batchSwap.value) {\r\n      return batchSwap.value.returnAmounts.map((amount, i) => {\r\n        const _amount = bnum(amount.toString()).abs().toString();\r\n        return formatUnits(_amount, withdrawalTokens.value[i].decimals);\r\n      });\r\n    }\r\n    return new Array(tokenCount.value).fill('0');\r\n  });\r\n\r\n  const proportionalAmounts = computed((): string[] => {\r\n    if (isDeepPool.value) {\r\n      return proportionalMainTokenAmounts.value;\r\n    }\r\n    return proportionalPoolTokenAmounts.value;\r\n  });\r\n\r\n  const fullAmounts = computed(() => {\r\n    if (isProportional.value) return proportionalAmounts.value;\r\n\r\n    return new Array(tokenCount.value).fill('0').map((_, i) => {\r\n      return i === tokenOutIndex.value ? tokenOutAmount.value || '0' : '0';\r\n    });\r\n  });\r\n\r\n  const fullAmountsScaled = computed((): string[] =>\r\n    fullAmounts.value.map((amount, i) =>\r\n      parseUnits(amount, withdrawalTokens.value[i].decimals).toString()\r\n    )\r\n  );\r\n\r\n  /**\r\n   * The full input amounts array minus slippage,\r\n   * if the amount is not 0 or a single asset exact out case.\r\n   */\r\n  const amountsOut = computed(() => {\r\n    return fullAmounts.value.map((amount, i) => {\r\n      if (amount === '0' || exactOut.value) return amount;\r\n      if (isProportional.value && isShallowComposableStablePool.value)\r\n        return amount;\r\n\r\n      return minusSlippage(amount, withdrawalTokens.value[i].decimals);\r\n    });\r\n  });\r\n\r\n  /**\r\n   * The BPT value to be used for the withdrawal transaction without accounting for slippage.\r\n   */\r\n  const fullBPTIn = computed((): string => {\r\n    if (isProportional.value) {\r\n      const _bpt = bnum(propBptIn.value)\r\n        .minus(formatUnits(bptBuffer.value), 18)\r\n        .toString();\r\n      return parseUnits(_bpt, poolDecimals.value).toString();\r\n    }\r\n    if (!exactOut.value)\r\n      return parseUnits(absMaxBpt.value, poolDecimals.value).toString(); // Single asset max withdrawal\r\n\r\n    // Else single asset exact out amount case\r\n\r\n    if (isDeepPool.value) {\r\n      if (shouldUseBatchRelayer.value) {\r\n        return batchRelayerSwap.value?.outputs?.amountsIn || '0';\r\n      }\r\n      return batchSwap.value?.returnAmounts?.[0]?.toString() || '0';\r\n    } else if (isShallowComposableStablePool.value) return queryBptIn.value;\r\n\r\n    return poolCalculator\r\n      .bptInForExactTokenOut(tokenOutAmount.value, tokenOutIndex.value)\r\n      .toString();\r\n  });\r\n\r\n  /**\r\n   * The BPT value to be used for the withdrawal transaction accounting for slippage.\r\n   * BPT value should be adjusted to account for slippage when:\r\n   * - single asset exact out\r\n   * - A shallow ComposableStable proportional exit (because we need to use BPTInForExactTokensOut)\r\n   */\r\n  const bptIn = computed((): string => {\r\n    if (exactOut.value) return addSlippageScaled(fullBPTIn.value);\r\n    if (isShallowComposableStablePool.value && !singleAssetMaxed.value) {\r\n      return addSlippageScaled(fullBPTIn.value);\r\n    }\r\n\r\n    return fullBPTIn.value.toString();\r\n  });\r\n\r\n  const normalizedBPTIn = computed((): string =>\r\n    formatUnits(bptIn.value, poolDecimals.value)\r\n  );\r\n\r\n  const hasAmounts = computed(() =>\r\n    fullAmounts.value.some(amount => bnum(amount).gt(0))\r\n  );\r\n\r\n  const singleAssetMaxes = computed((): string[] => {\r\n    if (isDeepPool.value || isShallowComposableStablePool.value)\r\n      return fetchedSingleAssetMaxes.value;\r\n\r\n    try {\r\n      return poolTokens.value.map((token, tokenIndex) => {\r\n        return formatUnits(\r\n          poolCalculator\r\n            .exactBPTInForTokenOut(bptBalanceScaled.value, tokenIndex)\r\n            .toString(),\r\n          token.decimals\r\n        );\r\n      });\r\n    } catch (error) {\r\n      if ((error as Error).message.includes('MIN_BPT_IN_FOR_TOKEN_OUT')) {\r\n        setError(WithdrawalError.SINGLE_ASSET_WITHDRAWAL_MIN_BPT_LIMIT);\r\n        return poolTokens.value.map((token, tokenIndex) => {\r\n          return formatUnits(\r\n            poolCalculator\r\n              .exactBPTInForTokenOut(\r\n                parseUnits(absMaxBpt.value, poolDecimals.value).toString(),\r\n                tokenIndex\r\n              )\r\n              .toString(),\r\n            token.decimals\r\n          );\r\n        });\r\n      }\r\n      return [];\r\n    }\r\n  });\r\n\r\n  // Checks if the single asset withdrawal is maxed out.\r\n  const singleAssetMaxed = computed(() => {\r\n    return (\r\n      singleAssetMaxes.value[tokenOutIndex.value] ===\r\n      fullAmounts.value[tokenOutIndex.value]\r\n    );\r\n  });\r\n\r\n  /**\r\n   * Checks if exactOut case, where the user is requesting\r\n   * a single asset withdrawal that is not maxed out.\r\n   */\r\n  const exactOut = computed(() => {\r\n    return !isProportional.value && !singleAssetMaxed.value;\r\n  });\r\n\r\n  /**\r\n   * Checks that the state of the form is a single asset withdrawal\r\n   * and if the single asset is maxed out.\r\n   */\r\n  const singleAssetMaxOut = computed(\r\n    () => !isProportional.value && singleAssetMaxed.value\r\n  );\r\n\r\n  const priceImpact = computed((): number => {\r\n    if (amountExceedsPoolBalance.value) return 1;\r\n    if (!hasAmounts.value || isProportional.value) return 0;\r\n\r\n    return poolCalculator\r\n      .priceImpact(fullAmounts.value, {\r\n        exactOut: exactOut.value,\r\n        tokenIndex: tokenOutIndex.value,\r\n        queryBPT: fullBPTIn.value,\r\n      })\r\n      .toNumber();\r\n  });\r\n\r\n  const highPriceImpact = computed(() =>\r\n    bnum(priceImpact.value).isGreaterThanOrEqualTo(HIGH_PRICE_IMPACT)\r\n  );\r\n\r\n  const fiatAmounts = computed((): string[] =>\r\n    fullAmounts.value.map((amount, i) =>\r\n      toFiat(amount, withdrawalTokens.value[i]?.address)\r\n    )\r\n  );\r\n\r\n  const fiatTotal = computed((): string =>\r\n    fiatAmounts.value.reduce(\r\n      (total, amount) => bnum(total).plus(amount).toString(),\r\n      '0'\r\n    )\r\n  );\r\n\r\n  const fiatTotalLabel = computed((): string =>\r\n    fNum(fiatTotal.value, FNumFormats.fiat)\r\n  );\r\n\r\n  const shouldFetchBatchSwap = computed(\r\n    (): boolean =>\r\n      pool.value && isDeepPool.value && bnum(normalizedBPTIn.value).gt(0)\r\n  );\r\n\r\n  const shouldUseBatchRelayer = computed((): boolean => {\r\n    if (!isDeepPool.value || !pool.value?.onchain?.linearPools) return false;\r\n\r\n    // If batchSwap has any 0 return amounts, we should use batch relayer\r\n    if (batchSwap.value) {\r\n      const returnAmounts = batchSwap.value.returnAmounts;\r\n      return hasBpt.value && returnAmounts.some(amount => bnum(amount).eq(0));\r\n    }\r\n\r\n    return false;\r\n  });\r\n\r\n  // Token amounts out to pass in to batch swap transaction and used as limits.\r\n  const batchSwapAmountsOutMap = computed((): Record<string, string> => {\r\n    const allTokensWithAmounts = fullAmountsScaled.value.map((amount, i) => [\r\n      tokenAddresses.value[i].toLowerCase(),\r\n      amount,\r\n    ]);\r\n    const onlyTokensWithAmounts = allTokensWithAmounts\r\n      .filter(([, amount]) => bnum(amount).gt(0))\r\n      .map(([token, amount]) => {\r\n        return [\r\n          token,\r\n          exactOut.value ? amount : minusSlippageScaled(amount.toString()),\r\n        ];\r\n      });\r\n    return Object.fromEntries(onlyTokensWithAmounts);\r\n  });\r\n\r\n  // An array of BPT values to be passed into the batch swap tx\r\n  const batchSwapBPTIn = computed((): string[] => {\r\n    if (singleAssetMaxOut.value) return [bptBalanceScaled.value];\r\n    if (exactOut.value) {\r\n      return batchSwap.value ? batchSwap.value.returnAmounts : [];\r\n    }\r\n\r\n    const poolTokenSum = bnSum(proportionalPoolTokenAmounts.value).toString();\r\n\r\n    const fractionalBPTIn = proportionalPoolTokenAmounts.value\r\n      .map(poolTokenAmount => {\r\n        const fraction = bnum(poolTokenAmount).div(poolTokenSum);\r\n        return fraction\r\n          .times(normalizedBPTIn.value)\r\n          .toFixed(poolDecimals.value, OldBigNumber.ROUND_DOWN);\r\n      })\r\n      .filter(BPT => bnum(BPT).gt(0));\r\n\r\n    return fractionalBPTIn.map(bptFraction =>\r\n      parseUnits(bptFraction, poolDecimals.value).toString()\r\n    );\r\n  });\r\n\r\n  const batchSwapTokensOut = computed((): string[] => {\r\n    if (singleAssetMaxOut.value) return [tokenOut.value];\r\n    return tokenAddresses.value.map(address => address.toLowerCase());\r\n  });\r\n\r\n  const batchSwapKind = computed(\r\n    (): SwapType =>\r\n      exactOut.value ? SwapType.SwapExactOut : SwapType.SwapExactIn\r\n  );\r\n\r\n  const batchRelayerTokenOut = computed(\r\n    (): string => pool.value?.wrappedTokens?.[tokenOutIndex.value] || ''\r\n  );\r\n\r\n  /**\r\n   * METHODS\r\n   */\r\n  async function initMath(): Promise<void> {\r\n    await getBptOutGuide();\r\n    propBptIn.value = bptBalance.value;\r\n\r\n    if (shouldFetchBatchSwap.value) {\r\n      swapPromises.value.push(fetchExitData);\r\n      if (!processingSwaps.value) processSwaps();\r\n    }\r\n  }\r\n\r\n  function resetMath(): void {\r\n    initMath();\r\n    tokenOutAmount.value = '';\r\n  }\r\n\r\n  /**\r\n   * Returns wrappedToken price rate for conversion to stable.\r\n   * @param wrappedToken the wrapped linear pool token address.\r\n   */\r\n  function scaledWrappedTokenRateFor(wrappedToken: string): string {\r\n    if (!pool.value?.onchain?.linearPools) return '0';\r\n\r\n    const normalPriceRate =\r\n      Object.values(pool.value.onchain.linearPools).find(linearPool =>\r\n        isSameAddress(linearPool.wrappedToken.address, wrappedToken)\r\n      )?.wrappedToken?.priceRate || '0';\r\n\r\n    return parseUnits(normalPriceRate, 18).toString();\r\n  }\r\n\r\n  /**\r\n   * Given either BPT in or the exact tokens out, fetches batch swap\r\n   * required, where return amounts are the opposite of amounts.\r\n   * @param amounts either BPT in amounts or exact out amounts\r\n   * @param tokensOut tokens to recieve\r\n   * @param swapType defaults to exact in\r\n   */\r\n  async function getBatchSwap(\r\n    amounts: string[] | null = null,\r\n    tokensOut: string[] | null = null,\r\n    swapType: SwapType = SwapType.SwapExactIn\r\n  ): Promise<BatchSwapOut> {\r\n    loadingData.value = true;\r\n\r\n    amounts = amounts || batchSwapBPTIn.value;\r\n    const tokensIn = amounts.map(() => pool.value.address);\r\n    const fetchPools = !batchSwap.value; // Only needs to be fetched on first call\r\n\r\n    try {\r\n      const result = await getBalancer().swaps.queryBatchSwapWithSor({\r\n        tokensIn: tokensIn,\r\n        tokensOut: tokensOut || batchSwapTokensOut.value,\r\n        swapType,\r\n        amounts,\r\n        fetchPools: {\r\n          fetchPools,\r\n          fetchOnChain: true,\r\n        },\r\n      });\r\n      loadingData.value = false;\r\n      return result;\r\n    } catch (error) {\r\n      if (\r\n        error instanceof BalancerError &&\r\n        (error as BalancerError)?.code ===\r\n          BalancerErrorCode.SWAP_ZERO_RETURN_AMOUNT\r\n      ) {\r\n        // The batch swap can fail if amounts are greater than supported by pool balances\r\n        // in this case we can return 0 amounts which will lead to an attempt via getBatchRelayerSwap()\r\n        loadingData.value = false;\r\n        return {\r\n          returnAmounts: Array(amounts.length).fill('0'),\r\n          swaps: [],\r\n          assets: [],\r\n        };\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Given either BPT in or the exact wrapped tokens out to convert to stables,\r\n   * fetches batch swap using the relayer required, where return amounts are the\r\n   * opposite of amounts.\r\n   * @param amounts either BPT in amounts or exact out amounts\r\n   * @param tokensOut wrapped tokens to convert to stables\r\n   * @param swapType defaults to exact in\r\n   */\r\n  async function getBatchRelayerSwap(\r\n    amounts: string[] | null = null,\r\n    tokensOut: string[] | null = null,\r\n    exactOut = false\r\n  ): Promise<TransactionData> {\r\n    loadingData.value = true;\r\n\r\n    amounts = amounts || batchSwapBPTIn.value.map(amount => amount.toString());\r\n    tokensOut = tokensOut || pool.value.wrappedTokens || [];\r\n    const fetchPools = !batchRelayerSwap.value; // Only needs to be fetched on first call\r\n\r\n    const rates: string[] = [];\r\n    tokensOut.forEach((tokenOut, i) => {\r\n      rates[i] = scaledWrappedTokenRateFor(tokenOut);\r\n    });\r\n\r\n    // BatchRelayer can be used to swap from bpt>waToken then automatically unwrap to underlying.\r\n    const result = await balancerContractsService.batchRelayer.stableExitStatic(\r\n      account.value,\r\n      pool.value.address,\r\n      amounts,\r\n      tokensOut,\r\n      rates,\r\n      slippageScaled.value,\r\n      exactOut,\r\n      fetchPools\r\n    );\r\n\r\n    loadingData.value = false;\r\n    return result;\r\n  }\r\n\r\n  // Fetch single asset max out for current tokenOut using batch swaps.\r\n  // Set max out returned from batchSwap in state.\r\n  async function getSingleAssetMaxOut(): Promise<void> {\r\n    if (isShallowComposableStablePool.value) {\r\n      const result = await poolExchange.queryExit(\r\n        getSigner(),\r\n        amountsOut.value.map(() => '0'),\r\n        tokensOut.value,\r\n        bptBalance.value,\r\n        tokenOutIndex.value,\r\n        false\r\n      );\r\n      let tokens = pool.value.tokens.map(t => t.address);\r\n      if (isSameAddress(tokenOut.value, nativeAsset.address))\r\n        tokens = replaceWethWithEth(tokens);\r\n      const actualIndex = indexOfAddress(tokens, tokenOut.value);\r\n      const maxOut = formatUnits(\r\n        result.amountsOut[actualIndex].toString(),\r\n        tokenOutDecimals.value\r\n      );\r\n      fetchedSingleAssetMaxes.value[tokenOutIndex.value] = maxOut;\r\n    } else if (isDeepPool.value) {\r\n      batchSwap.value = await getBatchSwap(\r\n        [bptBalanceScaled.value],\r\n        [tokenOut.value]\r\n      );\r\n\r\n      const batchSwapAmountOut = bnum(\r\n        batchSwap.value.returnAmounts[0].toString()\r\n      ).abs();\r\n\r\n      if (batchSwapAmountOut.gt(0)) {\r\n        const amountOut = formatUnits(\r\n          batchSwapAmountOut.toString(),\r\n          tokenOutDecimals.value\r\n        );\r\n\r\n        fetchedSingleAssetMaxes.value[tokenOutIndex.value] = amountOut;\r\n      } else {\r\n        const _batchRelayerSwap = await getBatchRelayerSwap(\r\n          [bptBalanceScaled.value.toString()],\r\n          [batchRelayerTokenOut.value]\r\n        );\r\n\r\n        let amountOut = '0';\r\n        if (_batchRelayerSwap.outputs && _batchRelayerSwap.outputs.amountsOut) {\r\n          const batchRelayerAmountOut = bnum(\r\n            _batchRelayerSwap.outputs.amountsOut[0].toString()\r\n          ).abs();\r\n          amountOut = formatUnits(\r\n            batchRelayerAmountOut.toString(),\r\n            tokenOutDecimals.value\r\n          );\r\n        }\r\n\r\n        fetchedSingleAssetMaxes.value[tokenOutIndex.value] = amountOut;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * High level function that uses withdrawal state to\r\n   * decide what swap should be fetched and sets it.\r\n   */\r\n  async function fetchExitData(): Promise<void> {\r\n    if (!isDeepPool.value && !isShallowComposableStablePool.value) return;\r\n\r\n    if (isShallowComposableStablePool.value) {\r\n      await getQueryBptIn();\r\n    } else {\r\n      // Is deep pool, use batch swap or relayer.\r\n      if (isProportional.value) {\r\n        batchSwap.value = await getBatchSwap();\r\n        if (shouldUseBatchRelayer.value) {\r\n          batchRelayerSwap.value = await getBatchRelayerSwap();\r\n        }\r\n      } else if (exactOut.value) {\r\n        const amountsOut = fullAmountsScaled.value.filter(amount =>\r\n          bnum(amount).gt(0)\r\n        );\r\n        batchSwap.value = await getBatchSwap(\r\n          amountsOut,\r\n          [tokenOut.value],\r\n          SwapType.SwapExactOut\r\n        );\r\n\r\n        if (shouldUseBatchRelayer.value) {\r\n          batchRelayerSwap.value = await getBatchRelayerSwap(\r\n            amountsOut.map(amount => amount.toString()),\r\n            [batchRelayerTokenOut.value],\r\n            true\r\n          );\r\n        }\r\n      } else {\r\n        // Single asset max out case\r\n        batchSwap.value = await getBatchSwap(\r\n          [bptBalanceScaled.value],\r\n          [tokenOut.value]\r\n        );\r\n\r\n        if (shouldUseBatchRelayer.value) {\r\n          batchRelayerSwap.value = await getBatchRelayerSwap(\r\n            [bptBalanceScaled.value.toString()],\r\n            [batchRelayerTokenOut.value]\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async function getQueryBptIn() {\r\n    if (!isShallowComposableStablePool.value) return;\r\n\r\n    const normalizedBptIn = bnum(bptBalance.value).plus(1).toString();\r\n\r\n    try {\r\n      loadingData.value = true;\r\n      const result = await poolExchange.queryExit(\r\n        getSigner(),\r\n        amountsOut.value,\r\n        tokensOut.value,\r\n        normalizedBptIn,\r\n        singleAssetMaxOut.value ? tokenOutIndex.value : null,\r\n        exactOut.value\r\n      );\r\n      queryBptIn.value = result.bptIn.toString();\r\n      loadingData.value = false;\r\n    } catch (error) {\r\n      console.error('Failed to fetch queryJoin', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetches BPT out given 10% of pool token balances in. This value can then be\r\n   * used as a guide for proportional exits in the shallow ComposableStable case.\r\n   */\r\n  async function getBptOutGuide() {\r\n    if (!isShallowComposableStablePool.value) return;\r\n\r\n    loadingData.value = true;\r\n\r\n    // Refetch onchain data for pool.\r\n    const [_pool] = await new PoolDecorator([cloneDeep(pool.value)]).decorate(\r\n      allTokens.value\r\n    );\r\n\r\n    const bptIn = _pool.onchain?.totalSupply || '0';\r\n    const amountsOut = Object.values(_pool.onchain?.tokens || []).map(t =>\r\n      formatUnits(\r\n        parseUnits(t.balance, t.decimals).mul(1000).div(10000),\r\n        t.decimals\r\n      )\r\n    );\r\n\r\n    try {\r\n      const result = await poolExchange.queryExit(\r\n        getSigner(),\r\n        amountsOut,\r\n        tokensOut.value,\r\n        bptIn,\r\n        null,\r\n        false\r\n      );\r\n      evmGuideBptIn.value = result.bptIn.toString();\r\n      loadingData.value = false;\r\n    } catch (error) {\r\n      console.error('Failed to fetch queryExit', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * WATCHERS\r\n   */\r\n  watch(tokenOut, () => {\r\n    tokenOutAmount.value = '';\r\n    if (isDeepPool.value || isShallowComposableStablePool.value)\r\n      getSingleAssetMaxOut();\r\n  });\r\n\r\n  watch(isProportional, () => {\r\n    if (isDeepPool.value || isShallowComposableStablePool.value)\r\n      getSingleAssetMaxOut();\r\n  });\r\n\r\n  watch(isWalletReady, async () => {\r\n    await forChange(dynamicDataLoading, false);\r\n    initMath();\r\n  });\r\n\r\n  watch(account, () => initMath());\r\n\r\n  watch(tokenOutAmount, async (newAmount, oldAmount) => {\r\n    if (!isEqual(oldAmount, newAmount)) {\r\n      /**\r\n       * If a single asset exit and the input values change we\r\n       * need to refetch the swap to get the required BPT in.\r\n       */\r\n      if (!isProportional.value) {\r\n        swapPromises.value.push(fetchExitData);\r\n        if (!processingSwaps.value) processSwaps();\r\n      }\r\n    }\r\n  });\r\n\r\n  return {\r\n    // computed\r\n    hasAmounts,\r\n    fullAmounts,\r\n    amountsOut,\r\n    fiatAmounts,\r\n    tokenOutAmount,\r\n    propBptIn,\r\n    bptIn,\r\n    bptBalance,\r\n    hasBpt,\r\n    fiatTotalLabel,\r\n    fiatTotal,\r\n    priceImpact,\r\n    highPriceImpact,\r\n    proportionalAmounts,\r\n    proportionalPoolTokenAmounts,\r\n    singleAssetMaxes,\r\n    exactOut,\r\n    singleAssetMaxOut,\r\n    tokenOutPoolBalance,\r\n    shouldFetchBatchSwap,\r\n    batchSwap,\r\n    batchSwapAmountsOutMap,\r\n    batchSwapKind,\r\n    shouldUseBatchRelayer,\r\n    batchRelayerSwap,\r\n    loadingData,\r\n    // methods\r\n    initMath,\r\n    resetMath,\r\n    fetchExitData,\r\n  };\r\n}\r\n"],"names":["WithdrawalError","state","reactive","setError","error","resetTxState","parseError","i18n","txInProgress","computed","useWithdrawalState","pool","nativeAsset","useTokens","replaceWethWithEth","useTokenHelpers","batchRelayerApproval","useRelayerApprovalTx","RelayerType","tokensOut","poolTokens","isDeep","tokensListExclBpt","tokenOutIndex","maxSlider","toRefs","useWithdrawMath","isProportional","ref","tokenOut","propBptIn","tokenOutAmount","loadingData","queryBptIn","evmGuideBptIn","batchSwap","batchRelayerSwap","fetchedSingleAssetMaxes","isWalletReady","getSigner","account","useWeb3","toFiat","fNum","useNumbers","allTokens","balances","balanceFor","getToken","dynamicDataLoading","minusSlippage","addSlippageScaled","minusSlippageScaled","useSlippage","isWeightedPool","isDeepPool","isShallowComposableStablePool","usePool","slippageScaled","useUserSettings","swapPromises","processingSwaps","processSwaps","usePromiseSequence","poolCalculator","PoolCalculator","poolExchange","PoolExchange","tokenAddresses","tokenCount","address","tokenOutDecimals","poolDecimals","_b","_a","withdrawalTokens","bptBalance","bptBalanceScaled","parseUnits","absMaxBpt","poolMax","bnum","OldBigNumber","hasBpt","tokenOutPoolBalance","tokens","token","amountExceedsPoolBalance","shouldUseBptBuffer","bptBuffer","SHALLOW_COMPOSABLE_STABLE_BUFFER","proportionalPoolTokenAmounts","fixedRatioOverride","receive","proportionalMainTokenAmounts","shouldUseBatchRelayer","amount","i","_amount","formatUnits","proportionalAmounts","fullAmounts","_","fullAmountsScaled","amountsOut","exactOut","fullBPTIn","_bpt","_e","_d","_c","bptIn","singleAssetMaxed","normalizedBPTIn","hasAmounts","singleAssetMaxes","tokenIndex","singleAssetMaxOut","priceImpact","highPriceImpact","HIGH_PRICE_IMPACT","fiatAmounts","fiatTotal","total","fiatTotalLabel","FNumFormats","shouldFetchBatchSwap","returnAmounts","batchSwapAmountsOutMap","onlyTokensWithAmounts","batchSwapBPTIn","poolTokenSum","bnSum","poolTokenAmount","BPT","bptFraction","batchSwapTokensOut","batchSwapKind","SwapType","batchRelayerTokenOut","initMath","getBptOutGuide","fetchExitData","resetMath","scaledWrappedTokenRateFor","wrappedToken","normalPriceRate","linearPool","isSameAddress","getBatchSwap","amounts","swapType","tokensIn","fetchPools","result","getBalancer","BalancerError","BalancerErrorCode","getBatchRelayerSwap","rates","balancerContractsService","getSingleAssetMaxOut","t","actualIndex","indexOfAddress","maxOut","batchSwapAmountOut","amountOut","_batchRelayerSwap","batchRelayerAmountOut","getQueryBptIn","normalizedBptIn","_pool","PoolDecorator","cloneDeep","watch","forChange","newAmount","oldAmount","isEqual"],"mappings":"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"}